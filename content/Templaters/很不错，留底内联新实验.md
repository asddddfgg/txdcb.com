<%*
// ==========================================
// ğŸš€ V5 - æœ€ç»ˆç¨³å®šä¸å®¹é”™å¢å¼ºç‰ˆ + å†…è”æ ·å¼å…¼å®¹æ€§
// æ ¸å¿ƒä¿®å¤ï¼š1. è§£å†³ [^\s æ–‡ä»¶åé”™è¯¯ã€‚ 2. è§£å†³ boolean true is not a function æ¨¡æ¿è§£æé”™è¯¯ã€‚
// æ–°å¢ï¼š3. ä½¿ç”¨å†…è”æ ·å¼ç¡®ä¿ Obsidian å…¼å®¹æ€§
// ==========================================

// ğŸ¨ é…ç½®åŒºåŸŸï¼ˆä¿æŒä¸å˜ï¼‰
const TARGET_FOLDER = "02 Notes"; 
const COLLECTION_TITLE_PREFIX = "æ ‡ç­¾æ”¶é›†ï¼š"; 
const QUERY_TIME_LABEL = "æŸ¥è¯¢æ—¶é—´"; 
const CONTENT_HEADER_PREFIX = "å…³äº"; 
const CONTENT_HEADER_SUFFIX = "çš„åè¨€é‡‘å¥"; 
const SOURCE_NOTE_EMOJI = "ğŸ’¡"; 

// ğŸš« æ’é™¤çš„æ–‡ä»¶åˆ—è¡¨ï¼ˆä¿æŒä¸å˜ï¼‰
const EXCLUDE_FILES = [
    "ä¸‡èƒ½æ ‡ç­¾æœç´¢å™¨.md",
    "å…¨ç«™æ ‡ç­¾æ€»è§ˆ.md"
];
const currentTemplateName = app.workspace.activeLeaf?.view?.file?.name || "æœªçŸ¥æ¨¡æ¿";
if (!EXCLUDE_FILES.includes(currentTemplateName)) {
    EXCLUDE_FILES.push(currentTemplateName);
}

// è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆ SEO å‹å¥½çš„ Description (130å­—å·¦å³)
function generateSeoDescription(tag, sentences) {
    const tagName = tag.replace('#', '');
    let description = `æœ¬é¡µé¢æ”¶é›†äº†å…³äºã€Œ${tagName}ã€ä¸»é¢˜çš„å…¨éƒ¨ç²¾é€‰åè¨€é‡‘å¥ã€æ€æƒ³ç¢ç‰‡å’Œæ·±åˆ»æ´å¯Ÿã€‚`;
    const firstThree = Array.from(sentences.keys()).slice(0, 3);
    if (firstThree.length > 0) {
        description += firstThree.map(s => s.substring(0, 50)).join('...').substring(0, 100);
    }
    description += `... (å…±${sentences.size}æ¡)ã€‚æ— è®ºæ‚¨æ˜¯åœ¨ç ”ç©¶${tagName}è¿˜æ˜¯å¯»æ±‚çµæ„Ÿï¼Œè¿™é‡Œéƒ½æ˜¯æ‚¨çš„ä¸€ç«™å¼çŸ¥è¯†åº“ã€‚`;
    return description.substring(0, 130) + '...';
}

// è¾…åŠ©å‡½æ•°ï¼šæ¸…ç†æ–‡ä»¶åä¸­çš„éæ³•å­—ç¬¦ (å¢å¼ºå®¹é”™)
function sanitizeFileName(filename) {
    // å…è®¸ä¸­æ–‡ã€è‹±æ–‡ã€æ•°å­—ã€ä¸‹åˆ’çº¿ã€è¿å­—ç¬¦
    // ç§»é™¤æ‰€æœ‰å…¶ä»–ç‰¹æ®Šå­—ç¬¦å’Œæ­£åˆ™è¡¨è¾¾å¼ç¬¦å·
    let cleaned = filename.replace(/[\\/*"<>:|?#[\]{}()^$+.]/g, '-'); 
    // ç§»é™¤è¿ç»­çš„è¿å­—ç¬¦
    cleaned = cleaned.replace(/-+/g, '-');
    return cleaned;
}

// è¾…åŠ©å‡½æ•°ï¼šå®‰å…¨æ–‡ä»¶æ“ä½œ
async function safeCreateFile(fileName, content) {
    const filePath = `${TARGET_FOLDER}/${fileName}`;
    try {
        const folder = app.vault.getAbstractFileByPath(TARGET_FOLDER);
        if (!folder) { await app.vault.createFolder(TARGET_FOLDER); }
        const targetFile = app.vault.getAbstractFileByPath(filePath);
        if (targetFile) { await app.vault.modify(targetFile, content); return 'updated'; } 
        else { await app.vault.create(filePath, content); return 'created'; }
    } catch (error) {
        console.error(`ä¿å­˜æ–‡ä»¶ ${filePath} æ—¶å‡ºé”™:`, error);
        return 'failed';
    }
}

// ğŸ•’ è®°å½•å¼€å§‹æ—¶é—´
const startTime = new Date();

// ğŸ” ç¬¬ä¸€æ­¥ï¼šæ‰«æå…¨ç«™æ‰€æœ‰æ ‡ç­¾
console.log("å¼€å§‹æ‰«æå…¨ç«™æ ‡ç­¾...");

// è·å–æ‰€æœ‰æ–‡ä»¶ï¼Œæ’é™¤æ”¶é›†æ–‡ä»¶å’ŒæŒ‡å®šæ’é™¤æ–‡ä»¶
const allFiles = app.vault.getMarkdownFiles()
    .filter(file => {
        if (EXCLUDE_FILES.includes(file.name) || 
            (file.name.includes(CONTENT_HEADER_SUFFIX) && file.path.includes(TARGET_FOLDER)) ||
            (file.name === "å…¨ç«™æ ‡ç­¾æ€»è§ˆ.md" && file.path.includes(TARGET_FOLDER)) ||
            file.path.toLowerCase().includes('templates')
            ) {
            return false;
        }
        return true;
    });

let allTags = new Set();
let tagFileMap = new Map();
let totalFilesScanned = 0;
let tagSentencesMap = new Map(); 

// ğŸ“– æ‰«ææ‰€æœ‰æ–‡ä»¶ï¼Œæå–æ ‡ç­¾å’Œå¥å­ (å®Œæ•´ V3 é€»è¾‘å›æ”¾)
for (const file of allFiles) {
    totalFilesScanned++;
    const content = await app.vault.read(file);
    const lines = content.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        if (!line || line.length < 10) continue;
        if (line.match(/^---/) || line.match(/^\s*```/)) continue; 
        
        // ä¸¥æ ¼çš„æ ‡ç­¾åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼ï¼š# åè·Ÿè‡³å°‘ä¸€ä¸ªå­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ã€è¿å­—ç¬¦æˆ–ä¸­æ–‡
        const tagMatches = line.match(/#[a-zA-Z0-9_\u4e00-\u9fa5][a-zA-Z0-9\/\-_\u4e00-\u9fa5]*/g);
        
        if (tagMatches) {
            const cleanTagsInLine = tagMatches.map(tag => tag.trim());
            
            let cleanSentence = line.replace(/^[>-]\s*/, '').replace(/\s+/g, ' ').replace(/`/g, '').trim();
            
            // è¿›ä¸€æ­¥è¿‡æ»¤æ— æ•ˆå¥å­
            if (cleanSentence.length >= 10 && 
                !cleanSentence.startsWith('//') &&
                !cleanSentence.includes('const ') &&
                !cleanSentence.includes('let ') &&
                !cleanSentence.includes('await ')) {

                cleanTagsInLine.forEach(tag => {
                    
                    const tagName = tag.substring(1); 
                    
                    if (tagName.length > 1 &&
                        !tag.match(/^#[0-9]/) && 
                        !tag.includes('SEARCH_TAG') &&
                        // æ’é™¤ CSS é¢œè‰²å€¼ (#f0f0f0 æˆ– #fff)
                        !/^#[0-9a-fA-F]{3,6}$/.test(tag) && 
                        // æ’é™¤è·¯å¾„/ä»£ç /ç‰¹æ®Šç¬¦å·æ ‡ç­¾
                        !tag.includes('//') && 
                        !tag.includes('[') && 
                        !tag.includes(']')) {
                        
                        allTags.add(tag);
                        
                        if (!tagSentencesMap.has(tag)) {
                            tagSentencesMap.set(tag, new Map());
                        }
                        
                        if (!tagSentencesMap.get(tag).has(cleanSentence)) {
                            tagSentencesMap.get(tag).set(cleanSentence, {
                                sourceFile: file.basename,
                                allTagsInLine: cleanTagsInLine 
                            });
                        }
                    }
                });
            }
        }
    }
}

// ğŸ“Š ç¬¬äºŒæ­¥ï¼šç”Ÿæˆæ”¶é›†æ–‡ä»¶
console.log(`å‘ç° ${allTags.size} ä¸ªæ ‡ç­¾ï¼Œå¼€å§‹ç”Ÿæˆæ”¶é›†æ–‡ä»¶åˆ° ${TARGET_FOLDER} æ–‡ä»¶å¤¹...`);

let createdFiles = 0;
let updatedFiles = 0;
let failedFiles = 0;
const allTagsArray = Array.from(allTags).sort();

// è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆå¡ç‰‡è¾¹æ¡†é¢œè‰²
function getBorderColorByTag(tag) {
    const colors = {
        "èŒåœº": "#e74c3c",
        "å“²å­¦": "#9b59b6", 
        "ç¤¾ä¼šè§‚å¯Ÿ": "#1abc9c",
        "ä¸ªäººæˆé•¿": "#f39c12",
        "çŠ€åˆ©åæ§½": "#e67e22",
        "AI": "#3498db",
        "æ€è€ƒ": "#2ecc71"
    };
    return colors[tag] || "#3498db"; // é»˜è®¤é¢œè‰²
}

// ä¸ºæ¯ä¸ªæ ‡ç­¾ç”Ÿæˆæ–‡ä»¶
for (const tag of allTagsArray) {
    const sentences = tagSentencesMap.get(tag) || new Map();
    const filesForTag = tagFileMap.get(tag) || new Set();
    
    if (sentences.size === 0) continue;
    
    const tagName = tag.replace('#', '');
    
    // **ğŸŒŸ å…³é”®ä¿®å¤ç‚¹ï¼šç”Ÿæˆæ–‡ä»¶åæ—¶ï¼Œå†æ¬¡ä½¿ç”¨ sanitizeFileNameï¼Œç¡®ä¿è·¯å¾„å®‰å…¨**
    const safeTagName = sanitizeFileName(tagName); 
    const safeFileName = `${safeTagName}${CONTENT_HEADER_SUFFIX}.md`; 
    const fileTitle = `${safeTagName}${CONTENT_HEADER_SUFFIX}`; 
    const seoDescription = generateSeoDescription(tag, sentences);
    
    // --- YAML Frontmatter ---
    let tagContent = `---
title: ${fileTitle}
description: ${seoDescription}
date: ${new Date().toISOString()}
tags: [${safeTagName}]
---
`;

    // --- HTMLå¤´éƒ¨å’Œå†…è”æ ·å¼ ---
    tagContent += `<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.7; color: #333; background-color: #f8f9fa; max-width: 800px; margin: 0 auto; padding: 2rem 1rem; box-sizing: border-box;">
    

<div style="text-align: center; margin: 2rem 0 1rem 0;">
    <h2 style="font-size: 1.8rem; color: #2c3e50; margin: 0 0 1rem 0;">${CONTENT_HEADER_PREFIX}${tagName}${CONTENT_HEADER_SUFFIX}</h2>
    <div style="height: 2px; background: linear-gradient(to right, transparent, ${getBorderColorByTag(tagName)}, transparent); margin: 0 auto 2rem auto; width: 80%;"></div>
</div>

<!-- å¡ç‰‡å®¹å™¨ -->
<div style="display: grid; gap: 2rem;">`;

    const sortedSentences = Array.from(sentences.entries())
        .sort(([sentenceA], [sentenceB]) => sentenceA.localeCompare(sentenceB));
    
    // ç”Ÿæˆå¡ç‰‡å†…å®¹
    for (const [sentence, info] of sortedSentences) {
        
        // ç¡®å®šå¡ç‰‡è¾¹æ¡†é¢œè‰²ï¼ˆæ ¹æ®ç¬¬ä¸€ä¸ªæ ‡ç­¾ï¼‰
        const firstTag = info.allTagsInLine[0]?.replace('#', '') || tagName;
        const cardBorderColor = getBorderColorByTag(firstTag);
        
        const displayTags = info.allTagsInLine
            .map(t => `<span style="background: #ecf0f1; padding: 0.2rem 0.6rem; border-radius: 12px; font-size: 0.8rem; color: #7f8c8d; margin-right: 0.5rem;">${t}</span>`)
            .join('');
        
        tagContent += `
<!-- å¡ç‰‡ -->
<article style="background: #fff; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05); border-left: 4px solid ${cardBorderColor}; transition: transform 0.2s ease, box-shadow 0.2s ease; cursor: pointer;"
         onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 5px 20px rgba(0, 0, 0, 0.1)';"
         onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 10px rgba(0, 0, 0, 0.05)'">
    <p style="font-size: 1.2rem; margin: 0; color: #2c3e50; line-height: 1.6;">${sentence}</p>
    <div style="margin-top: 1rem; font-size: 0.9rem; color: #95a5a6;">
        <div>${SOURCE_NOTE_EMOJI} <strong>æ¥æº</strong>ï¼š[[${info.sourceFile}]]</div>
        <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem;">
            ${displayTags}
        </div>
    </div>
</article>`;
    }
    
    // åº•éƒ¨ä¿¡æ¯
    tagContent += `
</div>

<!-- åˆ†éš”çº¿ -->
<div style="height: 1px; background: #eaeaea; margin: 3rem 0;"></div>

<!-- é¡µè„š -->
<footer style="text-align: center; color: #95a5a6; font-size: 0.9rem;">
    <p style="margin: 0 0 0.5rem 0;">âœ… <strong>è‡ªåŠ¨ç”Ÿæˆ</strong> Â· <strong>æœ€åæ›´æ–°</strong>ï¼š${new Date().toLocaleString()} Â· <strong>æ ‡ç­¾</strong>ï¼š${tag}</p>
    <p style="margin: 0;">â¬†ï¸ <strong>è¿”å›</strong> [[å…¨ç«™æ ‡ç­¾æ€»è§ˆ]]</p>
</footer>

</div>`;
    
    // ä¿å­˜æ–‡ä»¶åˆ°ç›®æ ‡æ–‡ä»¶å¤¹
    const result = await safeCreateFile(safeFileName, tagContent);
    
    if (result === 'created') { createdFiles++; } 
    else if (result === 'updated') { updatedFiles++; } 
    else { failedFiles++; }
}


// ğŸ“Š ç¬¬ä¸‰æ­¥ï¼šä¿å­˜æ€»è§ˆæ–‡ä»¶
let overviewContent = `# å…¨ç«™æ ‡ç­¾æ€»è§ˆ\n\n`;
overviewContent += `ğŸ“… **ç”Ÿæˆæ—¶é—´**ï¼š${new Date().toLocaleString()}\n`;
overviewContent += `ğŸ” **æ‰«ææ–‡ä»¶**ï¼š${totalFilesScanned} ä»½\n`;
overviewContent += `ğŸ·ï¸ **å‘ç°æ ‡ç­¾**ï¼š${allTags.size} ä¸ª\n\n`;
overviewContent += `---\n\n`;
overviewContent += `## æ ‡ç­¾ç»Ÿè®¡\n\n`;
overviewContent += `| æ ‡ç­¾ | å†…å®¹æ•°é‡ | æ¶‰åŠæ–‡ä»¶ | æŸ¥çœ‹æ”¶é›† |\n`;
overviewContent += `|:-----|:--------:|:--------:|:---------|\n`;
allTagsArray.forEach(tag => {
    const sentences = tagSentencesMap.get(tag) || new Map();
    const filesForTag = tagFileMap.get(tag) || new Set();
    if (sentences.size > 0) {
        const safeTagName = sanitizeFileName(tag.replace('#', ''));
        overviewContent += `| ${tag} | ${sentences.size} | ${filesForTag.size} | [[${safeTagName}${CONTENT_HEADER_SUFFIX}]] |\n`;
    }
});
overviewContent += `\n*æœ€åæ›´æ–°ï¼š${new Date().toLocaleString()}*`;
await safeCreateFile("å…¨ç«™æ ‡ç­¾æ€»è§ˆ.md", overviewContent);


// ğŸŠ ç»“æœæ˜¾ç¤º
const runTime = ((new Date() - startTime) / 1000).toFixed(2);
tR += `# âœ… ğŸ¯ å…¨ç«™æ ‡ç­¾è‡ªåŠ¨æ”¶é›†å®Œæˆï¼(å†…è”æ ·å¼å…¼å®¹ç‰ˆ)\n\n`;
tR += `## ğŸš€ æ ¸å¿ƒæ›´æ–°ï¼šå†…è”æ ·å¼ + ç¨³å®šæ€§å¢å¼º\n\n`;
tR += `> [!success] **å·²åˆ‡æ¢åˆ°å†…è”æ ·å¼æ–¹æ¡ˆ**\n`;
tR += `> 1. **å…¼å®¹æ€§ä¼˜åŒ–**ï¼šæ‰€æœ‰æ ·å¼æ”¹ä¸ºå†…è”ï¼Œç¡®ä¿åœ¨ Obsidian ä¸­å®Œç¾æ˜¾ç¤º\n`;
tR += `> 2. **æ–‡ä»¶åå®¹é”™**ï¼šæ–‡ä»¶åç”Ÿæˆæ—¶å·²å¼ºåˆ¶æ¸…ç†æ‰€æœ‰ç‰¹æ®Šå­—ç¬¦\n`;
tR += `> 3. **æ¨¡æ¿è§£æ**ï¼šè§£å†³äº† \`boolean true is not a function\` é”™è¯¯\n\n`;
tR += `## ğŸ“Š æ‰§è¡Œç»Ÿè®¡\n\n`;
tR += `| æŒ‡æ ‡ | æ•°é‡ |\n`;
tR += `|:---|:---:|\n`;
tR += `| æ‰«ææ–‡ä»¶ | ${totalFilesScanned} |\n`;
tR += `| **æœ‰æ•ˆæ ‡ç­¾** | **${createdFiles + updatedFiles}** |\n`;
tR += `| æ€»è€—æ—¶ | ${runTime} ç§’ |\n\n`;

tR += `## ğŸ¨ æ ·å¼é¢„è§ˆ\n`;
tR += `ç”Ÿæˆçš„æ–‡ä»¶ä½¿ç”¨äº†å†…è”æ ·å¼ï¼Œç¡®ä¿ï¼š\n`;
tR += `- âœ… å¡ç‰‡æ‚¬åœæ•ˆæœ\n`;
tR += `- âœ… å“åº”å¼å¸ƒå±€\n`;
tR += `- âœ… æ ‡ç­¾é¢œè‰²åŒºåˆ†\n`;
tR += `- âœ… ç§»åŠ¨ç«¯å‹å¥½\n\n`;

tR += `> ğŸ“… **æœ€åè¿è¡Œ**ï¼š${new Date().toLocaleString()}\n`;
%>