<%*
// ==========================================
// ğŸš€ SEOä¸“å®¶ç‰ˆï¼šæ ‡ç­¾é‡‘å¥æ”¶é›†å™¨ï¼ˆç»ˆæç¾åŒ–ç‰ˆï¼‰
// æ–°ç‰¹æ€§ï¼šèƒŒæ™¯å®Œç¾è´´åˆå†…å®¹ï¼Œä¸å†æœ‰å¤§ç‰‡ç°è‰²ç©ºç™½
// å·²åŒ…å«ï¼šæœ¬åœ°ç¾è§‚ + ç½‘é¡µå®Œç¾è·³è½¬
// ==========================================

if (typeof window._tagCollectorRunning !== 'undefined') {
    tR += "# âš ï¸ æ£€æµ‹åˆ°é‡å¤æ‰§è¡Œï¼Œå·²åœæ­¢\n\n> ä¸Šæ¬¡è¿è¡Œå°šæœªå®Œæˆï¼Œè¯·ç¨åå†è¯•";
    return;
}
window._tagCollectorRunning = true;

const cleanup = () => setTimeout(() => delete window._tagCollectorRunning, 1000);

try {
    // ==========================================
    // é…ç½®åŒºï¼ˆä¿æŒä¸å˜ï¼‰
    // ==========================================
    const TARGET_FOLDER = "02 Notes";
    const HEADER_SUFFIX = "çš„åè¨€é‡‘å¥";

    const EXCLUDE_FOLDERS = ["Templaters", "04 Private ç§äººæ–‡ä»¶å¤¹", "templates"];
    const EXCLUDE_FILES = new Set(["ä¸‡èƒ½æ ‡ç­¾æœç´¢å™¨.md", "å…¨ç«™æ ‡ç­¾æ€»è§ˆ.md", "tR.md"]);

    const SEO_CONFIG = {
        MINOR_UPDATE_THRESHOLD: 0.3,
        MAJOR_UPDATE_THRESHOLD: 0.5,
        CRITICAL_UPDATE_THRESHOLD: 0.8,
        DESCRIPTION_MIN_LENGTH: 120,
        DESCRIPTION_MAX_LENGTH: 140,
        MAX_KEYWORDS: 12,
        PRESERVE_EXISTING_SEO: true,
        FORCE_SEO_UPDATE: false
    };

    const COLORS = {
        "èŒåœº": "#ff6b6b", "å“²å­¦": "#5f27cd", "ç¤¾ä¼šè§‚å¯Ÿ": "#00b894", "ä¸ªäººæˆé•¿": "#fdcb6e",
        "çŠ€åˆ©åæ§½": "#fd79a8", "AI": "#3498db", "æ€è€ƒ": "#00cec9", "ç«äº‰å“²å­¦": "#8e44ad",
        "å¿ƒæ€è°ƒæ•´": "#16a085", "æˆåŠŸå­¦": "#e17055", "æƒåŠ›ç»“æ„": "#c0392b", "äººæ€§": "#27ae60"
    };

    function getColor(tag) { return COLORS[tag] || "#667eea"; }

    // ==========================================
    // SEO å‡½æ•°ï¼ˆå®Œæ•´ä¿ç•™ï¼Œç•¥å»é‡å¤ä»£ç ä»¥èŠ‚çœç¯‡å¹…ï¼Œå®é™…ä½¿ç”¨æ—¶ä¿æŒå®Œæ•´ï¼‰
    // ==========================================
    function parseFrontMatter(content) {
        const result = {};
        const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
        if (!frontMatterMatch) return null;
        const lines = frontMatterMatch[1].split('\n');
        for (const line of lines) {
            if (!line.trim() || line.startsWith('#')) continue;
            const match = line.match(/^([^:#]+):\s*(.+)$/);
            if (match) {
                let key = match[1].trim();
                let value = match[2].trim();
                if ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))) {
                    value = value.slice(1, -1);
                }
                result[key] = value;
            }
        }
        return result;
    }

    function shouldUpdateSEO(existingFrontMatter, newContentCount) {
        if (SEO_CONFIG.FORCE_SEO_UPDATE) return "critical";
        if (!existingFrontMatter) return true;
        const oldCount = parseInt(existingFrontMatter.quote_count || "0");
        if (isNaN(oldCount) || oldCount === 0) return true;
        const changeRatio = Math.abs(newContentCount - oldCount) / oldCount;
        if (changeRatio >= SEO_CONFIG.CRITICAL_UPDATE_THRESHOLD) return "critical";
        if (changeRatio >= SEO_CONFIG.MAJOR_UPDATE_THRESHOLD) return "major";
        if (changeRatio >= SEO_CONFIG.MINOR_UPDATE_THRESHOLD) return "minor";
        return false;
    }

    function generateStableSEODescription(tagName, contentCount) {
        const templates = [
            `æ¢ç´¢${tagName}çš„æ ¸å¿ƒæ™ºæ…§ï¼šç²¾é€‰${contentCount}æ¡${tagName}ç›¸å…³ç»å…¸åè¨€ä¸æ·±åº¦æ€è€ƒï¼Œæ¶µç›–äººç”Ÿå“²å­¦ã€å®è·µæŒ‡å—å’Œæ€ç»´å¯ç¤ºï¼ŒåŠ©æ‚¨æ·±å…¥ç†è§£${tagName}æœ¬è´¨ã€‚`,
            `æ·±åº¦è§£æ${tagName}çš„çœŸè°›ï¼šæ”¶å½•${contentCount}æ¡${tagName}æ™ºæ…§è¯­å½•ï¼Œä»å¤šç»´åº¦æ­ç¤º${tagName}çš„å®è·µä»·å€¼ä¸å“²å­¦æ€è€ƒï¼Œå¯è¿ªå¿ƒæ™ºæˆé•¿ã€‚`,
            `${tagName}æ™ºæ…§å®åº“ï¼š${contentCount}æ¡ç²¾é€‰åè¨€é‡‘å¥ï¼Œç³»ç»Ÿæ¢³ç†${tagName}çš„æ ¸å¿ƒè§‚ç‚¹ä¸å®ç”¨å»ºè®®ï¼Œä¸ºæ‚¨çš„æ€è€ƒä¸å†³ç­–æä¾›å‚è€ƒã€‚`,
            `èšç„¦${tagName}çš„æ·±åº¦æ´å¯Ÿï¼š${contentCount}æ¡ç»å…¸è¯­å½•æ±‡èš${tagName}æ€æƒ³ç²¾åï¼Œæ¶µç›–ç†è®ºæ€è€ƒä¸å®è·µåº”ç”¨ï¼ŒåŠ©æ‚¨æŒæ¡${tagName}è¦ä¹‰ã€‚`
        ];
        const hash = tagName.split('').reduce((a,c)=>a+c.charCodeAt(0),0);
        let desc = templates[hash % templates.length];
        if (desc.length < SEO_CONFIG.DESCRIPTION_MIN_LENGTH) desc += ` è¿™äº›${tagName}æ™ºæ…§å°†å¼•å¯¼æ‚¨æ·±å…¥æ€è€ƒä¸å®è·µåº”ç”¨ã€‚`;
        if (desc.length > SEO_CONFIG.DESCRIPTION_MAX_LENGTH) desc = desc.substring(0, SEO_CONFIG.DESCRIPTION_MAX_LENGTH-1) + 'ã€‚';
        return desc;
    }

    function extractStableKeywords(tagName, existingKeywords = "") {
        const base = new Set([tagName,'åè¨€','é‡‘å¥','è¯­å½•','æ™ºæ…§','å“²ç†','æ€è€ƒ','ç»å…¸','æ‘˜å½•','ç²¾å']);
        if (COLORS[tagName]) {
            const map = {
                "èŒåœº": ['èŒåœºæ™ºæ…§','å·¥ä½œå“²å­¦','èŒä¸šå‘å±•','ç®¡ç†å¿ƒå¾—','èŒåœºç»éªŒ'],
                "å“²å­¦": ['å“²å­¦æ€è€ƒ','äººç”Ÿå“²å­¦','æ€æƒ³æ·±åº¦','æ™ºæ…§å¯è¿ª','å“²ç†æ„Ÿæ‚Ÿ'],
                "ç¤¾ä¼šè§‚å¯Ÿ": ['ç¤¾ä¼šç°è±¡','ç¤¾ä¼šæ´å¯Ÿ','è§‚å¯Ÿæ€è€ƒ','ç¤¾ä¼šåˆ†æ','ç°å®æ€è€ƒ'],
                "ä¸ªäººæˆé•¿": ['æˆé•¿æ™ºæ…§','è‡ªæˆ‘æå‡','è¿›æ­¥æ€è€ƒ','å‘å±•å“²ç†','æˆé•¿å»ºè®®'],
                "AI": ['äººå·¥æ™ºèƒ½','AIæ€è€ƒ','ç§‘æŠ€æ™ºæ…§','æœªæ¥è¶‹åŠ¿','æŠ€æœ¯å“²å­¦']
            };
            map[tagName]?.forEach(k => base.add(k));
        }
        if (existingKeywords) {
            existingKeywords.split(',').map(k=>k.trim()).filter(k=>k).slice(0,6).forEach(k=>base.add(k));
        }
        return Array.from(base).slice(0, SEO_CONFIG.MAX_KEYWORDS);
    }

    function generateCompleteFrontMatter(tagName, contents, updateType = "new") {
        const sources = new Set(contents.map(c => c.sourceFile));
        const desc = generateStableSEODescription(tagName, contents.length);
        const kw = extractStableKeywords(tagName);
        const labels = {"new":"ğŸš€ æ–°é¡µé¢ç”Ÿæˆ","critical":"ğŸ”„ é‡å¤§å†…å®¹æ›´æ–°","major":"ğŸ“ˆ é‡è¦å†…å®¹æ‰©å……","minor":"ğŸ”§ å†…å®¹å¾®è°ƒ"};
        return `---
# ğŸ¯ SEOä¼˜åŒ–å…ƒæ•°æ® | ${labels[updateType]}
seo_title: "${tagName}çš„åè¨€é‡‘å¥ | ç²¾é€‰${contents.length}æ¡æ™ºæ…§è¯­å½•"
meta_description: "${desc}"
meta_keywords: "${kw.join(', ')}"
og_title: "${tagName}çš„åè¨€é‡‘å¥"
og_description: "${desc}"
og_type: "article"
twitter_card: "summary_large_image"
canonical_url: "https://wisdom.com/${encodeURIComponent(tagName)}"
robots: "index, follow, max-image-preview:large"

# ğŸ“Š å†…å®¹ç»Ÿè®¡
quote_count: ${contents.length}
source_count: ${sources.size}
last_content_update: "${new Date().toISOString()}"
seo_version: "v2.0"
update_type: "${updateType}"

# ğŸ·ï¸ æ ‡ç­¾åˆ†ç±»
primary_tag: "${tagName}"
category: "${COLORS[tagName] ? tagName : 'ç»¼åˆæ™ºæ…§'}"
tag_type: "åè¨€é‡‘å¥é›†åˆ"

# ğŸŒ ç¤¾äº¤åª’ä½“ä¼˜åŒ–
og_image: "/images/og-${tagName}.jpg"
og_image_alt: "${tagName}åè¨€é‡‘å¥ç²¾é€‰å°é¢"
twitter_site: "@WisdomQuotes"
twitter_creator: "@WisdomQuotes"

# ğŸ“± ç”¨æˆ·ä½“éªŒ
viewport: "width=device-width, initial-scale=1.0"
mobile_friendly: true
language: "zh-CN"
charset: "UTF-8"

# ğŸ”„ ç‰ˆæœ¬æ§åˆ¶
content_version: "1.0.0"
generated_by: "Obsidian SEOæ™ºèƒ½æ”¶é›†å™¨"
seo_stability: "stable"
last_seo_update: "${updateType === 'new' ? new Date().toISOString() : 'ä¿æŒä¸å˜'}"
---
`;
    }

    function generatePreservedFrontMatter(existingFM, contents) {
        const sources = new Set(contents.map(c => c.sourceFile));
        const old = parseInt(existingFM.quote_count || "0");
        const now = contents.length;
        const diff = now - old;
        return `---
# ğŸ¯ SEOä¼˜åŒ–å…ƒæ•°æ® | ğŸ“¥ å†…å®¹å¢é‡æ›´æ–°ï¼ˆSEOä¿æŒç¨³å®šï¼‰
seo_title: "${existingFM.seo_title || `${existingFM.primary_tag || 'æ ‡ç­¾'}çš„åè¨€é‡‘å¥`}"
meta_description: "${existingFM.meta_description || 'æœªè®¾ç½®'}"
meta_keywords: "${existingFM.meta_keywords || 'æœªè®¾ç½®'}"
og_title: "${existingFM.og_title || existingFM.seo_title || 'æœªè®¾ç½®'}"
og_description: "${existingFM.og_description || existingFM.meta_description || 'æœªè®¾ç½®'}"
og_type: "${existingFM.og_type || 'article'}"
twitter_card: "${existingFM.twitter_card || 'summary_large_image'}"
canonical_url: "${existingFM.canonical_url || 'https://wisdom.com/'}"
robots: "${existingFM.robots || 'index, follow, max-image-preview:large'}"

# ğŸ“Š å†…å®¹ç»Ÿè®¡ï¼ˆå·²æ›´æ–°ï¼‰
quote_count: ${now} # åŸ${old}æ¡ï¼Œæ–°å¢${diff>0?'+'+diff:diff}æ¡
source_count: ${sources.size}
last_content_update: "${new Date().toISOString()}"
seo_version: "${existingFM.seo_version || 'v1.0'}"
update_type: "content_only"

# ğŸ·ï¸ æ ‡ç­¾åˆ†ç±»
primary_tag: "${existingFM.primary_tag || 'æœªè®¾ç½®'}"
category: "${existingFM.category || 'æœªè®¾ç½®'}"
tag_type: "${existingFM.tag_type || 'æœªè®¾ç½®'}"

# ğŸŒ ç¤¾äº¤åª’ä½“ä¼˜åŒ–
og_image: "${existingFM.og_image || '/images/default-og.jpg'}"
og_image_alt: "${existingFM.og_image_alt || 'åè¨€é‡‘å¥ç²¾é€‰å°é¢'}"
twitter_site: "${existingFM.twitter_site || '@WisdomQuotes'}"
twitter_creator: "${existingFM.twitter_creator || '@WisdomQuotes'}"

# ğŸ“± ç”¨æˆ·ä½“éªŒ
viewport: "${existingFM.viewport || 'width=device-width, initial-scale=1.0'}"
mobile_friendly: "${existingFM.mobile_friendly || 'true'}"
language: "${existingFM.language || 'zh-CN'}"
charset: "${existingFM.charset || 'UTF-8'}"

# ğŸ”„ ç‰ˆæœ¬æ§åˆ¶
content_version: "${(parseFloat(existingFM.content_version || '1.0.0') + 0.1).toFixed(1)}"
generated_by: "Obsidian SEOæ™ºèƒ½æ”¶é›†å™¨"
seo_stability: "stable"
last_seo_update: "${existingFM.last_seo_update || 'ä¿æŒç¨³å®š'}"
stability_note: "å†…å®¹å¢é‡æ›´æ–°${diff>0?'+'+diff:diff}æ¡ï¼Œæ ¸å¿ƒSEOå…ƒæ•°æ®ä¿æŒä¸å˜ä»¥ç¡®ä¿æ’åç¨³å®š"
---
`;
    }

    // åŒå…¼å®¹æ ‡ç­¾å‡½æ•°ï¼ˆä¸å˜ï¼‰
    function generateTagHTML(tag, tagName) {
        const color = getColor(tagName);
        const vault = encodeURIComponent(app.vault.getName());
        const file = encodeURIComponent(tagName + HEADER_SUFFIX);
        return `<a href="obsidian://open?vault=${vault}&file=${file}"
                   style="background:${color}20;color:${color};padding:0.2rem 0.6rem;border-radius:12px;
                          text-decoration:none;font-weight:500;white-space:nowrap;"
                   onmouseover="this.style.background='${color}';this.style.color='white'"
                   onmouseout="this.style.background='${color}20';this.style.color='${color}'">
                    ${tag}
                </a><span style="display:none">[[${tagName}${HEADER_SUFFIX}]]</span>`;
    }

    // ==========================================
    // æ‰«ææ”¶é›†ï¼ˆä¸å˜ï¼‰
    // ==========================================
    const startTime = Date.now();
    const currentFile = app.workspace.activeLeaf?.view?.file?.name;
    if (currentFile) EXCLUDE_FILES.add(currentFile);

    const allFiles = app.vault.getMarkdownFiles().filter(f => {
        if (EXCLUDE_FILES.has(f.name)) return false;
        if (f.path.includes(TARGET_FOLDER) && f.name.includes(HEADER_SUFFIX)) return false;
        if (EXCLUDE_FOLDERS.some(folder => f.path.includes(folder))) return false;
        return true;
    });

    const allTags = new Set();
    const tagContentMap = new Map();
    let totalFilesScanned = 0;

    for (const file of allFiles) {
        totalFilesScanned++;
        const content = await app.vault.read(file);
        const lines = content.split('\n');
        for (const rawLine of lines) {
            let line = rawLine.trim();
            if (!line || line.length < 10 || line.startsWith('```') || line.startsWith('---')) continue;

            const tagMatches = line.match(/#[a-zA-Z0-9_\u4e00-\u9fa5][a-zA-Z0-9\/\-_\u4e00-\u9fa5]*/g);
            if (!tagMatches) continue;

            let cleanSentence = rawLine
                .replace(/^[>-]\s*/, '')
                .replace(/#[a-zA-Z0-9_\u4e00-\u9fa5][a-zA-Z0-9\/\-_\u4e00-\u9fa5]*/g, '')
                .replace(/\s+/g, ' ')
                .trim();

            if (cleanSentence.length < 10) continue;

            const validTags = tagMatches.filter(t => {
                const name = t.substring(1);
                return name.length > 1 && !/^#[0-9]/.test(t) && !/^#[0-9a-fA-F]{3,6}$/.test(t);
            });

            if (validTags.length === 0) continue;

            validTags.forEach(tag => {
                allTags.add(tag);
                if (!tagContentMap.has(tag)) tagContentMap.set(tag, []);
                const arr = tagContentMap.get(tag);
                if (!arr.some(i => i.sentence === cleanSentence)) {
                    arr.push({ sentence: cleanSentence, sourceFile: file.basename, allTags: [...validTags] });
                }
            });
        }
    }

    if (!app.vault.getAbstractFileByPath(TARGET_FOLDER)) await app.vault.createFolder(TARGET_FOLDER);

    // ==========================================
    // ç”Ÿæˆé¡µé¢ï¼ˆå…³é”®ç¾åŒ–ä¿®æ”¹åœ¨è¿™é‡Œï¼‰
    // ==========================================
    let createdFiles = 0, updatedFiles = 0, seoUpdatedFiles = 0, contentOnlyFiles = 0;
    const sortedTags = Array.from(allTags).sort();

    for (const tag of sortedTags) {
        const contents = tagContentMap.get(tag) || [];
        if (contents.length === 0) continue;

        const tagName = tag.replace('#', '');
        const color = getColor(tagName);
        const filePath = `${TARGET_FOLDER}/${tagName}${HEADER_SUFFIX}.md`;
        const existingFile = app.vault.getAbstractFileByPath(filePath);

        // SEO åˆ¤æ–­ï¼ˆä¸å˜ï¼‰
        let frontMatter = "";
        if (existingFile && SEO_CONFIG.PRESERVE_EXISTING_SEO) {
            const existingContent = await app.vault.read(existingFile);
            const fm = parseFrontMatter(existingContent);
            if (fm) {
                const decision = shouldUpdateSEO(fm, contents.length);
                if (decision === false) {
                    frontMatter = generatePreservedFrontMatter(fm, contents);
                    contentOnlyFiles++;
                } else {
                    frontMatter = generateCompleteFrontMatter(tagName, contents, decision);
                    seoUpdatedFiles++;
                }
            } else {
                frontMatter = generateCompleteFrontMatter(tagName, contents, "new");
                seoUpdatedFiles++;
            }
        } else {
            frontMatter = generateCompleteFrontMatter(tagName, contents, "new");
            seoUpdatedFiles++;
        }

        const sourceFiles = new Set(contents.map(c => c.sourceFile));

        // ============ å…³é”®ä¿®æ”¹ï¼šèƒŒæ™¯åªè¦†ç›–å†…å®¹åŒºåŸŸ ============
        let html = frontMatter;
        html += `<div style="font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:#1e293b;line-height:1.6;">`;

        // å½©è‰²é¡¶éƒ¨
        html += `<div style="background:${color};padding:3.5rem 1.5rem;text-align:center;color:white;">
            <h1 style="font-size:2.2rem;font-weight:700;margin:0 0 0.5rem;">å…³äºã€Œ${tagName}ã€çš„åè¨€é‡‘å¥</h1>
            <p style="opacity:0.9;margin:0;font-size:1.1rem;">æ”¶å½• ${contents.length} æ¡å†…å®¹ Â· æ¥è‡ª ${sourceFiles.size} ä»½ç¬”è®°</p>
        </div>`;

        // å†…å®¹åŒºï¼ˆå¸¦ç°è‰²èƒŒæ™¯ï¼‰
        html += `<div style="background:#f8fafc;padding:3rem 1.5rem;">`;
        html += `<div style="max-width:720px;margin:0 auto;">`;
        html += `<div style="display:grid;gap:1.5rem;">`;

        contents.sort((a,b) => a.sentence.localeCompare(b.sentence));

        for (const item of contents) {
            const firstTagName = item.allTags[0]?.replace('#','') || tagName;
            const cardColor = getColor(firstTagName);
            const tagLinks = item.allTags.map(t => {
                const tn = t.replace('#','');
                return generateTagHTML(t, tn);
            }).join('');

            html += `<article style="background:white;border-radius:12px;padding:1.8rem;border-left:5px solid ${cardColor};box-shadow:0 4px 12px rgba(0,0,0,0.06);">
                <div style="font-size:1.08rem;line-height:1.75;">${item.sentence}</div>
                <div style="margin-top:1.5rem;display:flex;justify-content:flex-end;">
                    <div style="display:flex;flex-wrap:wrap;gap:0.35rem;">${tagLinks}</div>
                </div>
            </article>`;
        }

        html += `</div>`; // grid end

        // é¡µè„šï¼ˆè¿˜åœ¨ç°è‰²èƒŒæ™¯å†…ï¼‰
        const vaultName = encodeURIComponent(app.vault.getName());
        const overviewFile = encodeURIComponent(TARGET_FOLDER + '/å…¨ç«™æ ‡ç­¾æ€»è§ˆ');

        html += `<div style="margin-top:4rem;padding:2rem;background:white;border-radius:12px;text-align:center;box-shadow:0 4px 12px rgba(0,0,0,0.06);">
            <p style="color:#64748b;margin-bottom:1rem;font-size:0.95rem;">ğŸ• ç”Ÿæˆæ—¶é—´ï¼š${new Date().toLocaleString('zh-CN')}</p>
            <a href="obsidian://open?vault=${vaultName}&file=${overviewFile}"
               style="display:inline-block;background:${color};color:white;text-decoration:none;padding:0.75rem 2rem;border-radius:8px;font-weight:600;font-size:1.05rem;">
               è¿”å›æ€»è§ˆ
            </a><span style="display:none">[[å…¨ç«™æ ‡ç­¾æ€»è§ˆ]]</span>
        </div>`;

        html += `</div></div></div></div>`; // ä¾æ¬¡å…³é—­ï¼šå†…å®¹åŒºã€èƒŒæ™¯åŒºã€æ•´ä½“å®¹å™¨

        if (existingFile) {
            await app.vault.modify(existingFile, html);
            updatedFiles++;
        } else {
            await app.vault.create(filePath, html);
            createdFiles++;
        }
    }

    // ==========================================
    // æ€»è§ˆé¡µé¢ï¼ˆä¿æŒä¸å˜ï¼‰
    // ==========================================
    const overviewContent = `# ğŸ·ï¸ å…¨ç«™æ ‡ç­¾æ€»è§ˆ - SEOæ™ºèƒ½ç‰ˆ

## ğŸ“ˆ ç»Ÿè®¡ä¿¡æ¯
- **æ‰«ææ–‡ä»¶**ï¼š${totalFilesScanned} ä»½
- **å‘ç°æ ‡ç­¾**ï¼š${sortedTags.length} ä¸ª
- **æ–°å»ºé¡µé¢**ï¼š${createdFiles} ä¸ª
- **æ›´æ–°é¡µé¢**ï¼š${updatedFiles} ä¸ª
- **SEOæ›´æ–°**ï¼š${seoUpdatedFiles} ä¸ª
- **ä»…å†…å®¹æ›´æ–°**ï¼š${contentOnlyFiles} ä¸ª
- **æ›´æ–°æ—¶é—´**ï¼š${new Date().toLocaleString()}

## ğŸ“‹ æ ‡ç­¾åˆ—è¡¨
${sortedTags.map(tag => {
    const c = tagContentMap.get(tag) || [];
    const s = new Set(c.map(i=>i.sourceFile));
    const n = tag.replace('#','');
    return `- **${tag}** (${c.length}æ¡ï¼Œ${s.size}ä¸ªæ–‡ä»¶) â†’ [[${n}${HEADER_SUFFIX}]]`;
}).join('\n')}

---

*æ™ºèƒ½æ›´æ–°å®Œæˆï¼š${new Date().toLocaleString('zh-CN')}*`;

    const ovPath = `${TARGET_FOLDER}/å…¨ç«™æ ‡ç­¾æ€»è§ˆ.md`;
    const ovFile = app.vault.getAbstractFileByPath(ovPath);
    if (ovFile) await app.vault.modify(ovFile, overviewContent);
    else await app.vault.create(ovPath, overviewContent);

    const runTime = ((Date.now() - startTime)/1000).toFixed(1);
    tR += `# âœ… æ ‡ç­¾é‡‘å¥æ”¶é›†å®Œæˆï¼ˆç»ˆæç¾åŒ–ç‰ˆï¼‰

- æ‰«ææ–‡ä»¶ï¼š${totalFilesScanned} ä»½
- å‘ç°æ ‡ç­¾ï¼š${sortedTags.length} ä¸ª
- æ–°å»º/æ›´æ–°ï¼š${createdFiles + updatedFiles} ä¸ª
- è€—æ—¶ï¼š${runTime} ç§’

âœ¨ æœ¬æ¬¡ä¼˜åŒ–ï¼š
â€¢ èƒŒæ™¯è‰²å®Œç¾è´´åˆå†…å®¹ï¼Œå†æ— å¤§ç‰‡ç°è‰²ç©ºç™½
â€¢ å¡ç‰‡ã€æŒ‰é’®ã€é—´è·å…¨é¢å¾®è°ƒï¼Œæ›´èˆ’é€‚ä¼˜é›…
â€¢ æœ¬åœ° + ç½‘é¡µç«¯ä½“éªŒä¸€è‡´ä¸æ»‘

> å¦‚éœ€å¼ºåˆ¶æ›´æ–°æ‰€æœ‰ SEOï¼Œå¯æŠŠä»£ç ä¸­çš„ FORCE_SEO_UPDATE æ”¹ä¸º true`;

} catch (e) {
    console.error(e);
    tR += `# âŒ æ‰§è¡Œå‡ºé”™\n\`\`\`\n${e.message}\n\`\`\``;
} finally {
    cleanup();
}
%>