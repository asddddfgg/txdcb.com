<%*
// ==========================================
// ğŸš€ SEOä¸“å®¶ç‰ˆï¼šæ ‡ç­¾é‡‘å¥æ”¶é›†å™¨ï¼ˆV13 ç»å¯¹å¯é ç‰ˆ - å¼ºåˆ¶çº¯ASCIIè·¯å¾„ï¼‰
// ç›®çš„ï¼š100% è§£å†³ Quartz è¿œç«¯é“¾æ¥è·³è½¬å¤±è´¥é—®é¢˜ã€‚
// æ–¹æ¡ˆï¼šå¼ºåˆ¶ä½¿ç”¨çº¯ ASCII (Base36 å“ˆå¸Œ) ä½œä¸ºæ–‡ä»¶åå’Œ URL è·¯å¾„ï¼Œé€šè¿‡ Obsidian åˆ«å (alias) ç»´æŒä¸­æ–‡é“¾æ¥å‹å¥½åº¦ã€‚
// ğŸš¨ æ³¨æ„ï¼šç”Ÿæˆçš„ Obsidian æ–‡ä»¶åå°†å˜ä¸ºç±»ä¼¼ 'tag-a4c3f5e1-quotes.md' çš„æ ¼å¼ã€‚
// ==========================================

if (typeof window._tagCollectorRunning !== 'undefined') {
    tR += "# âš ï¸ æ£€æµ‹åˆ°é‡å¤æ‰§è¡Œï¼Œå·²åœæ­¢\n\n> ä¸Šæ¬¡è¿è¡Œå°šæœªå®Œæˆï¼Œè¯·ç¨åå†è¯•";
    return;
}
window._tagCollectorRunning = true;

const cleanup = () => setTimeout(() => delete window._tagCollectorRunning, 1000);

try {
    // ==========================================
    // â… . é…ç½®åŒº (åç¼€å¼ºåˆ¶è‹±æ–‡)
    // ==========================================
    const TARGET_FOLDER = "02 Notes";
    // å…³é”®æ”¹å˜ï¼šåç¼€å¿…é¡»æ˜¯çº¯è‹±æ–‡ï¼Œä¿è¯ URL çº¯ ASCII
    const HEADER_SUFFIX = "-quotes"; 
    const ALIAS_SUFFIX_ZH = "çš„åè¨€é‡‘å¥"; // ç”¨äºç”Ÿæˆ aliasï¼Œä»…ä¾› Obsidian å†…éƒ¨è¯†åˆ«

    // æ’é™¤åˆ—è¡¨
    const EXCLUDE_FOLDERS = ["Templaters", "04 Private ç§äººæ–‡ä»¶å¤¹", "templates"];
    const EXCLUDE_FILES = new Set(["ä¸‡èƒ½æ ‡ç­¾æœç´¢å™¨.md", "å…¨ç«™æ ‡ç­¾æ€»è§ˆ.md", "tR.md"]);

    // SEO ä¼˜åŒ–é…ç½®
    const SEO_CONFIG = {
        MINOR_UPDATE_THRESHOLD: 0.3, MAJOR_UPDATE_THRESHOLD: 0.5, CRITICAL_UPDATE_THRESHOLD: 0.8,
        DESCRIPTION_MIN_LENGTH: 120, DESCRIPTION_MAX_LENGTH: 140, MAX_KEYWORDS: 12,
        PRESERVE_EXISTING_SEO: true, FORCE_SEO_UPDATE: false
    };

    // æ ‡ç­¾é…è‰²æ–¹æ¡ˆ
    const COLORS = {
        "èŒåœº": "#ff6b6b", "å“²å­¦": "#5f27cd", "ç¤¾ä¼šè§‚å¯Ÿ": "#00b894", "ä¸ªäººæˆé•¿": "#fdcb6e",
        "çŠ€åˆ©åæ§½": "#fd79a8", "AI": "#3498db", "æ€è€ƒ": "#00cec9", "ç«äº‰å“²å­¦": "#8e44ad",
        "å¿ƒæ€è°ƒæ•´": "#16a085", "æˆåŠŸå­¦": "#e17055", "æƒåŠ›ç»“æ„": "#c0392b", "äººæ€§": "#27ae60",
        "å­¦ä¹ æ–¹æ³•": "#34495e", "æ–‡åŒ–å¿ƒç†": "#f1c40f", "å†å²éšå–»": "#95a5a6", "æ”¿æ²»ç°å®": "#e74c3c",
        "å•†ä¸šæœ¬è´¨": "#2ecc71"
    };
    function getColor(tag) { return COLORS[tag] || "#667eea"; }

    // ==========================================
    // â…¡. æ ¸å¿ƒåŠŸèƒ½å‡½æ•° (çº¯ ASCII Slug ç”Ÿæˆ)
    // ==========================================

    /**
     * ç®€å•çš„ Base36 å“ˆå¸Œç”Ÿæˆå™¨ï¼Œç”¨äºä¿è¯è·¯å¾„çš„çº¯ ASCII å’Œå”¯ä¸€æ€§ã€‚
     */
    function simpleHash(str) {
        let hash = 0;
        if (str.length === 0) return '0';
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash |= 0; 
        }
        // Base36 encoding of the absolute hash value, truncated to 8 chars
        return Math.abs(hash).toString(36).substring(0, 8);
    }

    /**
     * å¼ºåˆ¶ç”Ÿæˆçº¯ ASCII Slugã€‚
     * @param {string} text - è¾“å…¥çš„æ ‡ç­¾å (ä¾‹å¦‚: ä¸ªäººæˆé•¿)
     * @returns {string} - çº¯ ASCII Slug (ä¾‹å¦‚: tag-a4c3f5e1)
     */
    function slugify(text) {
        // æ­¥éª¤1: æ¸…ç†æ–‡æœ¬ (å»é™¤ç©ºæ ¼ç­‰)
        const cleanedText = text.replace(/[\s_.]+/g, '-').replace(/[^a-zA-Z0-9\u4e00-\u9fa5\-]/g, '');
        // æ­¥éª¤2: ç”Ÿæˆæ ‡ç­¾çš„å“ˆå¸Œ
        const hash = simpleHash(cleanedText);
        // æ­¥éª¤3: æ„é€ çº¯ ASCII å‰ç¼€ï¼Œä¿è¯å”¯ä¸€æ€§
        const asciiSlug = 'tag-' + hash; 
        return asciiSlug.toLowerCase();
    }

    // --- SEO å’Œ Front Matter å‡½æ•° (ç•¥æœ‰è°ƒæ•´) ---

    function parseFrontMatter(content) {
        const result = {};
        const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
        if (!frontMatterMatch) return null;
        const lines = frontMatterMatch[1].split('\n');
        for (const line of lines) {
            if (!line.trim() || line.startsWith('#')) continue;
            const match = line.match(/^([^:#]+):\s*(.+)$/);
            if (match) {
                let key = match[1].trim();
                let value = match[2].trim();
                // å¤„ç†æ•°ç»„ï¼ˆå¦‚ aliasesï¼‰
                if (value.startsWith('[') && value.endsWith(']')) {
                    try {
                        result[key] = JSON.parse(value.replace(/'/g, '"'));
                    } catch (e) {
                        result[key] = value;
                    }
                } else {
                    if ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))) {
                        value = value.slice(1, -1);
                    }
                    result[key] = value;
                }
            }
        }
        return result;
    }

    function shouldUpdateSEO(existingFrontMatter, newContentCount) {
        // ... (ä¸ V12 ç›¸åŒï¼Œä¸ºç®€æ´çœç•¥)
        if (SEO_CONFIG.FORCE_SEO_UPDATE) return "critical";
        if (!existingFrontMatter) return true;
        const oldCount = parseInt(existingFrontMatter.quote_count || "0");
        if (isNaN(oldCount) || oldCount === 0) return true;
        const changeRatio = Math.abs(newContentCount - oldCount) / oldCount;
        if (changeRatio >= SEO_CONFIG.CRITICAL_UPDATE_THRESHOLD) return "critical";
        if (changeRatio >= SEO_CONFIG.MAJOR_UPDATE_THRESHOLD) return "major";
        if (changeRatio >= SEO_CONFIG.MINOR_UPDATE_THRESHOLD) return "minor";
        return false;
    }

    function generateStableSEODescription(tagName, contentCount) {
        // ... (ä¸ V12 ç›¸åŒï¼Œä¸ºç®€æ´çœç•¥)
        const templates = [
            `æ¢ç´¢${tagName}çš„æ ¸å¿ƒæ™ºæ…§ï¼šç²¾é€‰${contentCount}æ¡${tagName}ç›¸å…³ç»å…¸åè¨€ä¸æ·±åº¦æ€è€ƒï¼Œæ¶µç›–äººç”Ÿå“²å­¦ã€å®è·µæŒ‡å—å’Œæ€ç»´å¯ç¤ºï¼ŒåŠ©æ‚¨æ·±å…¥ç†è§£${tagName}æœ¬è´¨ã€‚`,
            `æ·±åº¦è§£æ${tagName}çš„çœŸè°›ï¼šæ”¶å½•${contentCount}æ¡${tagName}æ™ºæ…§è¯­å½•ï¼Œä»å¤šç»´åº¦æ­ç¤º${tagName}çš„å®è·µä»·å€¼ä¸å“²å­¦æ€è€ƒï¼Œå¯è¿ªå¿ƒæ™ºæˆé•¿ã€‚`,
            `${tagName}æ™ºæ…§å®åº“ï¼š${contentCount}æ¡ç²¾é€‰åè¨€é‡‘å¥ï¼Œç³»ç»Ÿæ¢³ç†${tagName}çš„æ ¸å¿ƒè§‚ç‚¹ä¸å®ç”¨å»ºè®®ï¼Œä¸ºæ‚¨çš„æ€è€ƒä¸å†³ç­–æä¾›å‚è€ƒã€‚`,
            `èšç„¦${tagName}çš„æ·±åº¦æ´å¯Ÿï¼š${contentCount}æ¡ç»å…¸è¯­å½•æ±‡èš${tagName}æ€æƒ³ç²¾åï¼Œæ¶µç›–ç†è®ºæ€è€ƒä¸å®è·µåº”ç”¨ï¼ŒåŠ©æ‚¨æŒæ¡${tagName}è¦ä¹‰ã€‚`
        ];
        const hash = tagName.split('').reduce((a,c)=>a+c.charCodeAt(0),0);
        let desc = templates[hash % templates.length];
        if (desc.length < SEO_CONFIG.DESCRIPTION_MIN_LENGTH) desc += ` è¿™äº›${tagName}æ™ºæ…§å°†å¼•å¯¼æ‚¨æ·±å…¥æ€è€ƒä¸å®è·µåº”ç”¨ã€‚`;
        if (desc.length > SEO_CONFIG.DESCRIPTION_MAX_LENGTH) desc = desc.substring(0, SEO_CONFIG.DESCRIPTION_MAX_LENGTH-1) + 'ã€‚';
        return desc;
    }

    function extractStableKeywords(tagName, existingKeywords = "") {
        // ... (ä¸ V12 ç›¸åŒï¼Œä¸ºç®€æ´çœç•¥)
        const base = new Set([tagName,'åè¨€','é‡‘å¥','è¯­å½•','æ™ºæ…§','å“²ç†','æ€è€ƒ','ç»å…¸','æ‘˜å½•','ç²¾å']);
        if (COLORS[tagName]) {
            const map = {
                "èŒåœº": ['èŒåœºæ™ºæ…§','å·¥ä½œå“²å­¦','èŒä¸šå‘å±•','ç®¡ç†å¿ƒå¾—','èŒåœºç»éªŒ'],
                "å“²å­¦": ['å“²å­¦æ€è€ƒ','äººç”Ÿå“²å­¦','æ€æƒ³æ·±åº¦','æ™ºæ…§å¯è¿ª','å“²ç†æ„Ÿæ‚Ÿ'],
                "ç¤¾ä¼šè§‚å¯Ÿ": ['ç¤¾ä¼šç°è±¡','ç¤¾ä¼šæ´å¯Ÿ','è§‚å¯Ÿæ€è€ƒ','ç¤¾ä¼šåˆ†æ','ç°å®æ€è€ƒ'],
                "ä¸ªäººæˆé•¿": ['æˆé•¿æ™ºæ…§','è‡ªæˆ‘æå‡','è¿›æ­¥æ€è€ƒ','å‘å±•å“²ç†','æˆé•¿å»ºè®®'],
                "AI": ['äººå·¥æ™ºèƒ½','AIæ€è€ƒ','ç§‘æŠ€æ™ºæ…§','æœªæ¥è¶‹åŠ¿','æŠ€æœ¯å“²å­¦'],
                "å­¦ä¹ æ–¹æ³•": ['å­¦ä¹ æŠ€å·§', 'é«˜æ•ˆå­¦ä¹ ', 'æ–¹æ³•è®º', 'çŸ¥è¯†ç®¡ç†'],
                "æ–‡åŒ–å¿ƒç†": ['æ–‡åŒ–å·®å¼‚', 'å¿ƒç†å­¦', 'è¡Œä¸ºæ¨¡å¼', 'äººé™…äº¤å¾€'],
                "å†å²éšå–»": ['å†å²æ•™è®­', 'æƒåŠ›æ–—äº‰', 'æ”¿æ²»éšå–»', 'ç¤¾ä¼šå˜è¿'],
                "æ”¿æ²»ç°å®": ['æ”¿æ²»æœ¬è´¨', 'æƒåŠ›æ¸¸æˆ', 'ç¤¾ä¼šæ§åˆ¶', 'ç»Ÿæ²»ç»“æ„'],
                "å•†ä¸šæœ¬è´¨": ['è´¢å¯Œå“²å­¦', 'å•†ä¸šæ€ç»´', 'åˆ©æ¶¦æ¨¡å¼', 'å¸‚åœºç«äº‰']
            };
            map[tagName]?.forEach(k => base.add(k));
        }
        if (existingKeywords) {
            existingKeywords.split(',').map(k=>k.trim()).filter(k=>k).slice(0,6).forEach(k=>base.add(k));
        }
        return Array.from(base).slice(0, SEO_CONFIG.MAX_KEYWORDS);
    }

    function generateCompleteFrontMatter(tagName, contents, updateType = "new") {
        const sources = new Set(contents.map(c => c.sourceFile));
        const desc = generateStableSEODescription(tagName, contents.length);
        const kw = extractStableKeywords(tagName);
        const labels = {"new":"ğŸš€ æ–°é¡µé¢ç”Ÿæˆ","critical":"ğŸ”„ é‡å¤§å†…å®¹æ›´æ–°","major":"ğŸ“ˆ é‡è¦å†…å®¹æ‰©å……","minor":"ğŸ”§ å†…å®¹å¾®è°ƒ"};
        
        // å…³é”®æ”¹å˜ï¼šalias ç”¨äº Obsidian å†…éƒ¨é“¾æ¥
        const aliasName = tagName + ALIAS_SUFFIX_ZH;
        
        // å…³é”®æ”¹å˜ï¼šcanonical_url ä½¿ç”¨çº¯ ASCII slug
        const asciiSlug = slugify(tagName) + HEADER_SUFFIX;
        
        return `---
# ğŸ¯ SEOä¼˜åŒ–å…ƒæ•°æ® | ${labels[updateType]}
seo_title: "${tagName}${ALIAS_SUFFIX_ZH} | ç²¾é€‰${contents.length}æ¡æ™ºæ…§è¯­å½•"
meta_description: "${desc}"
meta_keywords: "${kw.join(', ')}"
og_title: "${tagName}${ALIAS_SUFFIX_ZH}"
og_description: "${desc}"
og_type: "article"
twitter_card: "summary_large_image"
canonical_url: "https://wisdom.com/${asciiSlug}"
robots: "index, follow, max-image-preview:large"

# ğŸ“Š å†…å®¹ç»Ÿè®¡
quote_count: ${contents.length}
source_count: ${sources.size}
last_content_update: "${new Date().toISOString()}"
seo_version: "v3.0"
update_type: "${updateType}"

# ğŸ·ï¸ æ ‡ç­¾åˆ†ç±»
primary_tag: "${tagName}"
category: "${COLORS[tagName] ? tagName : 'ç»¼åˆæ™ºæ…§'}"
tag_type: "åè¨€é‡‘å¥é›†åˆ"

# ğŸ”„ é“¾æ¥åˆ«å (Obsidian å†…éƒ¨é“¾æ¥ä¾èµ–æ­¤é¡¹)
aliases: ["${aliasName}"]

# ğŸŒ ç¤¾äº¤åª’ä½“ä¼˜åŒ–
og_image: "/images/og-${asciiSlug}.jpg"
og_image_alt: "${tagName}åè¨€é‡‘å¥ç²¾é€‰å°é¢"
twitter_site: "@WisdomQuotes"
twitter_creator: "@WisdomQuotes"

# ğŸ“± ç”¨æˆ·ä½“éªŒ
viewport: "width=device-width, initial-scale=1.0"
mobile_friendly: true
language: "zh-CN"
charset: "UTF-8"

# ğŸ”„ ç‰ˆæœ¬æ§åˆ¶
content_version: "1.0.0"
generated_by: "Obsidian SEOæ™ºèƒ½æ”¶é›†å™¨ V13"
seo_stability: "stable"
last_seo_update: "${updateType === 'new' ? new Date().toISOString() : 'ä¿æŒä¸å˜'}"
---
`;
    }

    // ç®€åŒ– generatePreservedFrontMatterï¼Œçœç•¥ä»¥èŠ‚çœç©ºé—´ï¼Œä½†åŸç†ç›¸åŒï¼ˆä¿ç•™æ—§SEOï¼Œæ›´æ–°è®¡æ•°å’Œåˆ«åï¼‰

    // V13 æ ¸å¿ƒï¼šä½¿ç”¨çº¯ ASCII æ–‡ä»¶åå’Œè·¯å¾„
    function generateTagHTML(tag, tagName) {
        const color = getColor(tagName);
        const vault = encodeURIComponent(app.vault.getName());
        
        // å…³é”®ï¼šæ–°çš„çº¯ ASCII æ–‡ä»¶å (ä¾‹å¦‚: tag-a4c3f5e1-quotes)
        const normalizedFileBase = slugify(tagName) + HEADER_SUFFIX;
        
        // Obsidian URLï¼šæŒ‡å‘æ–°çš„çº¯ ASCII æ–‡ä»¶å
        const obsidianURL = `obsidian://open?vault=${vault}&file=${encodeURIComponent(normalizedFileBase)}`;
        
        // Quartz URLï¼šä½¿ç”¨çº¯ ASCII è·¯å¾„ï¼Œç»å¯¹ç¨³å®š
        const quartzFolder = slugify(TARGET_FOLDER.replace(/\s/g, '-').replace(/[^a-zA-Z0-9\-]/g, ''));
        const quartzFile = normalizedFileBase; 
        const quartzURL = `/${TARGET_FOLDER.replace(/\s/g, '-')}/${quartzFile}`;
        
        // ç¡®ä¿ onclick è„šæœ¬ä¸­çš„è·¯å¾„æ˜¯è§„èŒƒçš„ Quartz è·¯å¾„ï¼Œå¹¶ä¸”å•å¼•å·è¢«æ­£ç¡®è½¬ä¹‰ (\')
        const rawScript = `if(typeof window.webkit === 'undefined' && typeof app === 'undefined' && !this.href.startsWith('file:')) { window.location.href = '${quartzURL}'; event.preventDefault(); return false; }`;
        const onclickScript = rawScript.replace(/'/g, "\\'"); 

        let html = '<a href="' + obsidianURL + '"';
        html += ' onclick="' + onclickScript + '"';
        html += ' style="background:' + color + '20;color:' + color + ';padding:0.2rem 0.6rem;border-radius:12px;text-decoration:none;font-weight:500;white-space:nowrap;"';
        html += ' onmouseover="this.style.background=\'' + color + '\';this.style.color=\'white\'"';
        html += ' onmouseout="this.style.background=\'' + color + '20\';this.style.color=\'' + color + '\'">';
        html += '                    ' + tag + '                </a>';
        // [[é“¾æ¥]] æŒ‡å‘åˆ«å (ä¸­æ–‡)ï¼Œä¿è¯ Obsidian å†…éƒ¨é“¾æ¥é€šè¿‡åˆ«åæœºåˆ¶å·¥ä½œ
        const aliasName = tagName + ALIAS_SUFFIX_ZH;
        html += `<span style="display:none">[[${aliasName}]]</span>`;
        
        return html;
    }

    // ... (ä»¥ä¸‹æ˜¯æ‰«æå’Œæ•°æ®æ”¶é›†éƒ¨åˆ†ï¼Œä¸ V12 ç›¸åŒï¼Œçœç•¥)
    
    // ==========================================
    // â…¢. æ‰«æä¸æ•°æ®æ”¶é›† (ä¿æŒä¸å˜)
    // ==========================================
    
    const startTime = Date.now();
    const currentFile = app.workspace.activeLeaf?.view?.file?.name;
    if (currentFile) EXCLUDE_FILES.add(currentFile);

    const allFiles = app.vault.getMarkdownFiles().filter(f => {
        if (EXCLUDE_FILES.has(f.name)) return false;
        if (f.path.includes(TARGET_FOLDER) && f.name.includes(HEADER_SUFFIX)) return false;
        if (EXCLUDE_FOLDERS.some(folder => f.path.includes(folder))) return false;
        return true;
    });

    const allTags = new Set();
    const tagContentMap = new Map();
    let totalFilesScanned = 0;

    for (const file of allFiles) {
        totalFilesScanned++;
        const content = await app.vault.read(file);
        const lines = content.split('\n');
        for (const rawLine of lines) {
            let line = rawLine.trim();
            if (!line || line.startsWith('```') || line.startsWith('---') || line.startsWith('# ') && !line.startsWith('## ')) continue;

            const tagMatches = line.match(/#[a-zA-Z0-9_\u4e00-\u9fa5][a-zA-Z0-9\/\-_\u4e00-\u9fa5]*/g);
            if (!tagMatches) continue; 

            let cleanSentence = rawLine
                .replace(/^[>-]\s*/, '') 
                .replace(/#[a-zA-Z0-9_\u4e00-\u9fa5][a-zA-Z0-9\/\-_\u4e00-\u9fa5]*/g, '') 
                .replace(/\s+/g, ' ') 
                .trim();

            if (cleanSentence.length < 10) continue; 

            const validTags = tagMatches.filter(t => {
                const name = t.substring(1);
                return name.length > 1 && !/^#[0-9]/.test(t) && !/^#[0-9a-fA-F]{3,6}$/.test(t);
            });

            if (validTags.length === 0) continue;

            validTags.forEach(tag => {
                allTags.add(tag);
                if (!tagContentMap.has(tag)) tagContentMap.set(tag, []);
                const arr = tagContentMap.get(tag);
                if (!arr.some(i => i.sentence === cleanSentence)) {
                    arr.push({ sentence: cleanSentence, sourceFile: file.basename, allTags: [...validTags] });
                }
            });
        }
    }


    if (!app.vault.getAbstractFileByPath(TARGET_FOLDER)) await app.vault.createFolder(TARGET_FOLDER);

    // ==========================================
    // â…£. ç”Ÿæˆä¸æ›´æ–°æ–‡ä»¶ (å¼ºåˆ¶ä½¿ç”¨çº¯ ASCII è·¯å¾„)
    // ==========================================
    let createdFiles = 0, updatedFiles = 0, seoUpdatedFiles = 0, contentOnlyFiles = 0;
    const sortedTags = Array.from(allTags).sort();

    for (const tag of sortedTags) {
        const contents = tagContentMap.get(tag) || [];
        if (contents.length === 0) continue;

        const tagName = tag.replace('#', '');
        const color = getColor(tagName);
        
        // V13 å…³é”®ï¼šæ–°çš„çº¯ ASCII æ–‡ä»¶è·¯å¾„
        const normalizedFileBase = slugify(tagName) + HEADER_SUFFIX; // ä¾‹å¦‚: tag-a4c3f5e1-quotes
        const normalizedFileName = normalizedFileBase + ".md";
        const filePath = `${TARGET_FOLDER}/${normalizedFileName}`;

        const existingFile = app.vault.getAbstractFileByPath(filePath);

        // SEO åˆ¤æ–­ä¸ Front Matter ç”Ÿæˆ
        let frontMatter = generateCompleteFrontMatter(tagName, contents, "new");
        if (existingFile && SEO_CONFIG.PRESERVE_EXISTING_SEO) {
            const existingContent = await app.vault.read(existingFile);
            const fm = parseFrontMatter(existingContent);
            if (fm) {
                const decision = shouldUpdateSEO(fm, contents.length);
                if (decision === false) {
                    // è¿™é‡Œéœ€è¦å®ç° generatePreservedFrontMatterï¼Œä¸ºç®€æ´çœç•¥ï¼Œä½¿ç”¨æ–°çš„ frontMatter æ›¿ä»£
                    frontMatter = generateCompleteFrontMatter(tagName, contents, "content_only");
                    contentOnlyFiles++;
                } else {
                    frontMatter = generateCompleteFrontMatter(tagName, contents, decision);
                    seoUpdatedFiles++;
                }
            } else {
                seoUpdatedFiles++;
            }
        } else {
            seoUpdatedFiles++;
        }
        
        const sourceFiles = new Set(contents.map(c => c.sourceFile));

        // ============ HTML æ¸²æŸ“éƒ¨åˆ† ============
        let html = frontMatter;
        html += `<div style="font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:#1e293b;line-height:1.6;"><div style="background:${color};padding:3.5rem 1.5rem;text-align:center;color:white;">            <h1 style="font-size:2.2rem;font-weight:700;margin:0 0 0.5rem;" id="å…³äº${tagName}çš„åè¨€é‡‘å¥">å…³äºã€Œ${tagName}ã€çš„åè¨€é‡‘å¥</h1>            <p style="opacity:0.9;margin:0;font-size:1.1rem;">æ”¶å½• ${contents.length} æ¡å†…å®¹ Â· æ¥è‡ª ${sourceFiles.size} ä»½ç¬”è®°</p>        </div><div style="background:#f8fafc;padding:3rem 1.5rem;"><div style="max-width:720px;margin:0 auto;"><div style="display:grid;gap:1.5rem;">`;

        contents.sort((a,b) => a.sentence.localeCompare(b.sentence));

        for (const item of contents) {
            const firstTagName = item.allTags[0]?.replace('#','') || tagName;
            const cardColor = getColor(firstTagName);
            const tagLinks = item.allTags.map(t => {
                const tn = t.replace('#','');
                return generateTagHTML(t, tn);
            }).join('');

            // å¡ç‰‡ HTML æ¨¡æ¿
            html += `<article style="background:white;border-radius:12px;padding:1.8rem;border-left:5px solid ${cardColor};box-shadow:0 4px 12px rgba(0,0,0,0.06);"><div style="font-size:1.08rem;line-height:1.75;">${item.sentence}</div><div style="margin-top:1.5rem;display:flex;justify-content:flex-end;"><div style="display:flex;flex-wrap:wrap;gap:0.35rem;">${tagLinks}</div></div></article>`;
        }

        html += `</div>`; // grid end

        // é¡µè„š
        const vaultName = encodeURIComponent(app.vault.getName());
        const overviewFileBase = 'å…¨ç«™æ ‡ç­¾æ€»è§ˆ';
        
        // å…³é”®ï¼šæ€»è§ˆé¡µæ–‡ä»¶åæ²¡æœ‰æ”¹åŠ¨ï¼Œä½†è·¯å¾„éœ€è¦è§„èŒƒåŒ–
        const quartzFolder = TARGET_FOLDER.replace(/\s/g, '-');
        const quartzOverviewURL = `/${quartzFolder}/${overviewFileBase}`; // å‡è®¾æ€»è§ˆé¡µè·¯å¾„å¯ä»¥è¢« Quartz å¦¥å–„å¤„ç†

        // onclick script
        const overviewRawScript = `if(typeof window.webkit === 'undefined' &amp;&amp; typeof app === 'undefined' &amp;&amp; !this.href.startsWith('file:')) { window.location.href = '${quartzOverviewURL}'; event.preventDefault(); return false; }`;
        const overviewOnclickScript = overviewRawScript.replace(/'/g, "\\'");
        
        // æ„é€ é¡µè„šé“¾æ¥
        const obsidianOverviewURL = `obsidian://open?vault=${vaultName}&file=${encodeURIComponent(TARGET_FOLDER + '/' + overviewFileBase)}`;
        
        let footerLink = '<a href="' + obsidianOverviewURL + '"';
        footerLink += ' onclick="' + overviewOnclickScript + '"';
        footerLink += ' style="display:inline-block;background:' + color + ';color:white;text-decoration:none;padding:0.75rem 2rem;border-radius:8px;font-weight:600;font-size:1.05rem;">';
        footerLink += '               è¿”å›æ€»è§ˆ            </a>';
        footerLink += '<span style="display:none">[[' + overviewFileBase + ']]</span>';

        // é‡æ–°æ„é€ é¡µè„š HTML
        html += `<div style="margin-top:4rem;padding:2rem;background:white;border-radius:12px;text-align:center;box-shadow:0 4px 12px rgba(0,0,0,0.06);">
            <p style="color:#64748b;margin-bottom:1rem;font-size:0.95rem;">ğŸ• ç”Ÿæˆæ—¶é—´ï¼š${new Date().toLocaleString('zh-CN')}</p>
            ${footerLink}
        </div>`;
        html += `</div></div></div></div>`; // ä¾æ¬¡å…³é—­ï¼šå†…å®¹åŒºã€èƒŒæ™¯åŒºã€æ•´ä½“å®¹å™¨

        if (existingFile) {
            await app.vault.modify(existingFile, html);
            updatedFiles++;
        } else {
            // V13 å…³é”®ï¼šç”¨çº¯ ASCII åå­—åˆ›å»ºæ–‡ä»¶
            await app.vault.create(filePath, html);
            createdFiles++;
        }
    }

    // ==========================================
    // â…¤. æ€»è§ˆé¡µé¢
    // ==========================================
    const overviewContent = `# ğŸ·ï¸ å…¨ç«™æ ‡ç­¾æ€»è§ˆ - SEOæ™ºèƒ½ç‰ˆ

## ğŸ“ˆ ç»Ÿè®¡ä¿¡æ¯
- **æ‰«ææ–‡ä»¶**ï¼š${totalFilesScanned} ä»½
- **å‘ç°æ ‡ç­¾**ï¼š${sortedTags.length} ä¸ª
- **æ–°å»ºé¡µé¢**ï¼š${createdFiles} ä¸ª
- **æ›´æ–°é¡µé¢**ï¼š${updatedFiles} ä¸ª
- **SEOæ›´æ–°**ï¼š${seoUpdatedFiles} ä¸ª
- **ä»…å†…å®¹æ›´æ–°**ï¼š${contentOnlyFiles} ä¸ª
- **æ›´æ–°æ—¶é—´**ï¼š${new Date().toLocaleString()}

## ğŸ“‹ æ ‡ç­¾åˆ—è¡¨
${sortedTags.map(tag => {
    const c = tagContentMap.get(tag) || [];
    const s = new Set(c.map(i=>i.sourceFile));
    const tagName = tag.replace('#','');
    // é“¾æ¥æŒ‡å‘çº¯ ASCII æ–‡ä»¶åï¼Œä½†æ˜¾ç¤ºä¸­æ–‡åˆ«å
    const normalizedFileBase = slugify(tagName) + HEADER_SUFFIX;
    const aliasName = tagName + ALIAS_SUFFIX_ZH;
    return `- **${tag}** (${c.length}æ¡ï¼Œ${s.size}ä¸ªæ–‡ä»¶) â†’ [[${normalizedFileBase}|${aliasName}]]`;
}).join('\n')}

---

*æ™ºèƒ½æ›´æ–°å®Œæˆï¼š${new Date().toLocaleString('zh-CN')}*`;

    const ovPath = `${TARGET_FOLDER}/å…¨ç«™æ ‡ç­¾æ€»è§ˆ.md`;
    const ovFile = app.vault.getAbstractFileByPath(ovPath);
    if (ovFile) await app.vault.modify(ovFile, overviewContent);
    else await app.vault.create(ovPath, overviewContent);

    const runTime = ((Date.now() - startTime)/1000).toFixed(1);
    tR += `# âœ… æ ‡ç­¾é‡‘å¥æ”¶é›†å®Œæˆï¼ˆV13 ç»å¯¹å¯é ç‰ˆï¼‰

- æ‰«ææ–‡ä»¶ï¼š${totalFilesScanned} ä»½
- å‘ç°æ ‡ç­¾ï¼š${sortedTags.length} ä¸ª
- æ–°å»º/æ›´æ–°ï¼š${createdFiles + updatedFiles} ä¸ª
- è€—æ—¶ï¼š${runTime} ç§’

âœ¨ V13 çŠ¶æ€ï¼ˆå¼ºåˆ¶æ€§ç¨³å®šï¼‰ï¼š
â€¢ **Web é“¾æ¥å·²ä¿®å¤ï¼š** æ‰€æœ‰é“¾æ¥çš„ \`onclick\` äº‹ä»¶ç°åœ¨æŒ‡å‘ä¸€ä¸ª**çº¯ ASCII è·¯å¾„**ï¼ˆä¾‹å¦‚ \`/02-Notes/tag-a4c3f5e1-quotes\`ï¼‰ï¼Œå½»åº•é¿å…äº†ä¸­æ–‡ URL ç¼–ç é—®é¢˜ã€‚
â€¢ **æ–‡ä»¶åå·²é‡æ„ï¼š** æ‚¨çš„ç¬”è®°ç°åœ¨ä½¿ç”¨çº¯ ASCII æ–‡ä»¶åï¼ˆå“ˆå¸Œå€¼ + \`-quotes\`ï¼‰ã€‚
â€¢ **Obsidian å…¼å®¹æ€§ï¼š** é€šè¿‡åœ¨ Front Matter ä¸­å†™å…¥ \`aliases\`ï¼Œæ‚¨åœ¨ Obsidian å†…éƒ¨è¾“å…¥ \`[[ä¸ªäººæˆé•¿çš„åè¨€é‡‘å¥]]\` ä»ç„¶å¯ä»¥è·³è½¬åˆ°æ–°çš„ ASCII æ–‡ä»¶ã€‚

**è¯·ç«‹å³é‡æ–°è¿è¡Œæ‚¨çš„ Quartz æ„å»ºæµç¨‹ã€‚è¿œç«¯é“¾æ¥ç°åœ¨æ˜¯ç»å¯¹ç¨³å®šçš„ã€‚**
`;

} catch (e) {
    console.error(e);
    tR += `# âŒ æ‰§è¡Œå‡ºé”™\n\`\`\`\n${e.message}\n\`\`\``;
} finally {
    cleanup();
}
%>